{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _class, _temp2;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _classnames = require('classnames');\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nvar _List = require('./List');\n\nvar _List2 = _interopRequireDefault(_List);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // `PureComponent` is only available in React >= 15.3.0.\n\n\nvar PureComponent = _react2.default.PureComponent || _react2.default.Component;\nvar ScrollableList = (_temp2 = _class = function (_PureComponent) {\n  _inherits(ScrollableList, _PureComponent);\n\n  function ScrollableList() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, ScrollableList);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ScrollableList.__proto__ || Object.getPrototypeOf(ScrollableList)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      // Is initialized during the first `componentDidUpdate()` call.\n      verticalPadding: 0 // Proxy `<List/>` methods.\n\n    }, _this.focusItem = function (index) {\n      return _this.list.focusItem(index);\n    }, _this.focus = function () {\n      return _this.list.focus();\n    }, _this.clearFocus = function () {\n      return _this.list.clearFocus();\n    }, _this.onListItemsChanged = function () {\n      return _this.list.onListItemsChanged();\n    }, _this.onKeyDown = function (event) {\n      return _this.list.onKeyDown(event);\n    }, _this.chooseFocusedItem = function () {\n      return _this.list.chooseFocusedItem();\n    }, _this.getFocusedItemIndex = function () {\n      return _this.list.getFocusedItemIndex();\n    }, _this.focusItem = function (index) {\n      return _this.list.focusItem(index);\n    }, _this.onFocusItem = function (index, options) {\n      var onFocusItem = _this.props.onFocusItem;\n\n      if (onFocusItem) {\n        onFocusItem(index, options);\n      } // When `<List/>` calls `.focusItem()` in `componentDidMount()`\n      // `this.list` doesn't exist yet, hence the check.\n\n\n      if (index !== undefined && _this.list) {\n        _this.showItem(index);\n      }\n    }, _this.getListNode = function () {\n      return _this.list.list;\n    }, _this.storeListRef = function (ref) {\n      return _this.list = ref;\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  _createClass(ScrollableList, [{\n    key: 'showItem',\n    // Fully shows an option having the `value` (scrolls to it if neccessary)\n    value: function showItem(index) {\n      var edge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n      var children = this.props.children;\n      var itemElement = this.list.itemRefs[index];\n      var isFirstItem = index === 0;\n      var isLastItem = index === _react2.default.Children.count(children) - 1;\n\n      if (isFirstItem) {\n        return this.showTopLine(itemElement, true);\n      } else if (isLastItem) {\n        return this.showBottomLine(itemElement, true);\n      }\n\n      switch (edge) {\n        case 'top':\n          return this.showTopLine(itemElement);\n\n        case 'bottom':\n          return this.showBottomLine(itemElement);\n      }\n    }\n  }, {\n    key: 'showTopLine',\n    value: function showTopLine(itemElement, isFirstItem) {\n      var verticalPadding = this.state.verticalPadding;\n      var topLine = itemElement.offsetTop;\n\n      if (isFirstItem) {\n        topLine -= verticalPadding;\n      }\n\n      if (topLine < this.getListNode().scrollTop) {\n        this.getListNode().scrollTop = topLine;\n      }\n    }\n  }, {\n    key: 'showBottomLine',\n    value: function showBottomLine(itemElement, isLastItem) {\n      var verticalPadding = this.state.verticalPadding;\n      var bottomLine = itemElement.offsetTop + itemElement.offsetHeight;\n\n      if (isLastItem) {\n        bottomLine += verticalPadding;\n      }\n\n      if (bottomLine > this.getListNode().scrollTop + this.getListNode().offsetHeight) {\n        this.getListNode().scrollTop = bottomLine - this.getListNode().offsetHeight;\n      }\n    }\n  }, {\n    key: 'itemOnClick',\n    value: function itemOnClick(value, event) {\n      var _this2 = this; // Collapse the `<Select/>`.\n      // Doing `setValue` in a callback\n      // because otherwise `setValue()` would result in\n      // updating props and calling `getDerivedStateFromProps()`\n      // which reads `autocomplete_value` which is being reset inside `.toggle()`.\n\n\n      this.expandable.collapse().then(function () {\n        return _this2.setValue(value);\n      });\n    } // Calculates height of the item list.\n\n  }, {\n    key: 'calculateHeight',\n    value: function calculateHeight() {\n      var children = this.props.children;\n      var height = this.getListNode().scrollHeight;\n      var verticalPadding = parseInt(window.getComputedStyle(this.getListNode()).paddingTop);\n      var state = {\n        height: height,\n        verticalPadding: verticalPadding // Calculate the appropriate list height.\n\n      };\n\n      if (this.isOverflown()) {\n        state.maxHeight = this.calculateScrollableListHeight(height, verticalPadding);\n      }\n\n      this.setState(state);\n    }\n  }, {\n    key: 'calculateScrollableListHeight',\n    value: function calculateScrollableListHeight(height, verticalPadding) {\n      var _props = this.props,\n          scrollMaxItems = _props.scrollMaxItems,\n          children = _props.children; // Adding vertical padding here so that it shows `scrollMaxItems` items fully.\n      // Also gives a peek on the `scrollMaxItems + 1`th item by showing a half of it.\n\n      return (height - 2 * verticalPadding) * ((scrollMaxItems + 0.5) / _react2.default.Children.count(children)) + verticalPadding;\n    }\n  }, {\n    key: 'isOverflown',\n    value: function isOverflown() {\n      var _props2 = this.props,\n          scrollMaxItems = _props2.scrollMaxItems,\n          children = _props2.children;\n      return scrollMaxItems > 0 && _react2.default.Children.count(children) > scrollMaxItems;\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.calculateHeight();\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props3 = this.props,\n          scrollBarPadding = _props3.scrollBarPadding,\n          className = _props3.className,\n          children = _props3.children,\n          rest = _objectWithoutProperties(_props3, ['scrollBarPadding', 'className', 'children']);\n\n      var maxHeight = this.state.maxHeight;\n      var listStyle = void 0; // Makes the list scrollable if it's max height is constrained.\n\n      if (maxHeight !== undefined) {\n        listStyle = {\n          maxHeight: maxHeight + 'px'\n        };\n      }\n\n      return _react2.default.createElement(_List2.default, _extends({}, rest, {\n        ref: this.storeListRef,\n        onFocusItem: this.onFocusItem,\n        style: listStyle,\n        className: (0, _classnames2.default)(className, {\n          'rrui__scrollable': this.isOverflown()\n        })\n      }), children);\n    }\n  }]);\n\n  return ScrollableList;\n}(PureComponent), _class.propTypes = {\n  // // A list of items.\n  // items : PropTypes.arrayOf\n  // (\n  // \tPropTypes.shape\n  // \t({\n  // \t\t// Item value (may be `undefined`).\n  // \t\tvalue : PropTypes.any,\n  // \t\t// Item label (may be `undefined`).\n  // \t\tlabel : PropTypes.string,\n  // \t\t// Item icon component.\n  // \t\ticon  : PropTypes.func,\n  // \t\t// Render custom content (a React component).\n  // \t\t// Receives `{ value, label }` properties.\n  // \t\tcontent : PropTypes.func\n  // \t})\n  // ),\n  // Maximum items fitting the list height (scrollable).\n  // Set to `0` to disable overflow.\n  // Is `6` by default.\n  scrollMaxItems: _propTypes2.default.number.isRequired,\n  // Whether should add `margin-right` for scrollbar width on overflow.\n  // Is `true` by default.\n  scrollBarPadding: _propTypes2.default.bool,\n  className: _propTypes2.default.string\n}, _class.defaultProps = {\n  scrollMaxItems: 6,\n  scrollBarPadding: true\n}, _temp2);\nexports.default = ScrollableList;","map":null,"metadata":{},"sourceType":"script"}