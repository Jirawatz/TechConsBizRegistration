{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _class, _temp2;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _classnames = require('classnames');\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nvar _scrollIntoViewIfNeeded = require('scroll-into-view-if-needed');\n\nvar _scrollIntoViewIfNeeded2 = _interopRequireDefault(_scrollIntoViewIfNeeded);\n\nvar _Close = require('./Close');\n\nvar _Close2 = _interopRequireDefault(_Close);\n\nvar _OnFocusOut = require('./OnFocusOut');\n\nvar _OnFocusOut2 = _interopRequireDefault(_OnFocusOut);\n\nvar _OnTapOutside = require('./OnTapOutside');\n\nvar _OnTapOutside2 = _interopRequireDefault(_OnTapOutside);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // `PureComponent` is only available in React >= 15.3.0.\n\n\nvar PureComponent = _react2.default.PureComponent || _react2.default.Component;\n/**\r\n * Usage:\r\n *\r\n * <button onClick={() => this.expandable.toggle()}>\r\n *   Toggle\r\n * </button>\r\n *\r\n * <Expandable ref={ref => this.expandable = ref}>\r\n *   ...\r\n * </Expandable>\r\n *\r\n * Methods:\r\n * * `.toggle()`\r\n * * `.expand()`\r\n * * `.collapse()`\r\n * * `.isExpanded()`\r\n */\n\nvar Expandable = (_temp2 = _class = function (_PureComponent) {\n  _inherits(Expandable, _PureComponent);\n\n  function Expandable() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Expandable);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Expandable.__proto__ || Object.getPrototypeOf(Expandable)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      // This initialization is required for `if (expand === expanded)`.\n      expanded: false\n    }, _this.isExpanded = function () {\n      return _this.state.expanded;\n    }, _this.expand = function (parameters) {\n      return _this.toggle(true, parameters);\n    }, _this.collapse = function () {\n      return _this.toggle(false);\n    }, _this.toggle = function (expand) {\n      var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _this$props = _this.props,\n          onExpand = _this$props.onExpand,\n          onExpanded = _this$props.onExpanded,\n          onCollapse = _this$props.onCollapse,\n          onCollapsed = _this$props.onCollapsed,\n          preload = _this$props.preload,\n          onPreloadStateChange = _this$props.onPreloadStateChange,\n          onPreloadError = _this$props.onPreloadError;\n      var _this$state = _this.state,\n          expanded = _this$state.expanded,\n          isPreloading = _this$state.isPreloading; // If no `expand` argument provided then just toggle.\n\n      if (expand === undefined) {\n        expand = !expanded;\n      } // Don't collapse if already collapsed.\n      // Don't expand if already expanded\n      // until manually forcing a refresh of content.\n\n\n      var refreshingExpanded = void 0;\n\n      if (expand && expanded && parameters.refresh) {\n        refreshingExpanded = true;\n      }\n\n      if (expand === expanded && !refreshingExpanded) {\n        return Promise.resolve();\n      }\n\n      if (_this.isToggling && !refreshingExpanded) {\n        return Promise.resolve();\n      }\n\n      _this.isToggling = true; // Collapse.\n\n      if (!expand) {\n        if (_this.onTapOutsideRef) {\n          _this.onTapOutsideRef.stopListeningToTouches();\n        }\n\n        clearTimeout(_this.scrollIntoViewTimer);\n\n        if (onCollapse) {\n          onCollapse({\n            focusOut: _this.focusOut\n          });\n        } // Set `expanded` to `false` to play the collapse CSS animation.\n        // Once that animation is finished remove\n        // the contents of the `<Expanded/>` from DOM.\n\n\n        return new Promise(function (resolve) {\n          _this.setState({\n            expanded: false\n          }, function () {\n            if (onCollapsed) {\n              onCollapsed();\n            }\n\n            _this.removeFromDOMAfterCollapsed();\n\n            _this.isToggling = false;\n            resolve();\n          });\n        });\n      } // Expand.\n\n\n      return _this.preload().then(function () {\n        return new Promise(function (resolve) {\n          clearTimeout(_this.removeFromDOMTimer);\n\n          _this.setState({\n            shouldRender: true\n          }, // Without the 10ms delay for some reason the CSS \"expand\" animation won't play.\n          // Perhaps a browser decides to optimize two subsequent renders\n          // and doesn't render \"pre-expanded\" and \"expanded\" states separately.\n          // Even with a 0ms delay it would randomly play/not-play the expand animation.\n          function () {\n            if (onExpand) {\n              onExpand();\n            }\n\n            setTimeout(function () {\n              _this.setState({\n                expanded: true\n              }, function () {\n                if (onExpanded) {\n                  onExpanded();\n                }\n\n                _this.scrollIntoView();\n\n                resolve();\n\n                if (_this.onTapOutsideRef) {\n                  _this.onTapOutsideRef.listenToTouches();\n                }\n\n                _this.isToggling = false;\n              });\n            }, 10);\n          });\n        });\n      });\n    }, _this.removeFromDOMAfterCollapsed = function () {\n      var expandAnimationDuration = _this.props.expandAnimationDuration; // For some reason in IE 11 \"scroll into view\" scrolls\n      // to the top of the page, therefore turn it off for IE.\n\n      _this.removeFromDOMTimer = setTimeout(function () {\n        // Re-render to remove the options DOM nodes.\n        _this.setState({\n          shouldRender: false\n        });\n      }, expandAnimationDuration * 1.1);\n    }, _this.onKeyDown = function (event) {\n      if (event.defaultPrevented) {\n        return;\n      }\n\n      if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n        return;\n      }\n\n      switch (event.keyCode) {\n        // Collapse on \"Escape\".\n        case 27:\n          event.preventDefault(); // Collapse the list if it's expanded\n\n          return _this.collapse();\n      }\n    }, _this.onBlur = function (event) {\n      return _this.onFocusOutRef && _this.onFocusOutRef.onBlur(event);\n    }, _this.storeContainerNode = function (node) {\n      return _this.container = node;\n    }, _this.getContainerNode = function () {\n      return _this.container;\n    }, _this.storeOnTapOutsideRef = function (ref) {\n      return _this.onTapOutsideRef = ref;\n    }, _this.storeOnFocusOutRef = function (ref) {\n      return _this.onFocusOutRef = ref;\n    }, _this.onFocusOut = function (event) {\n      // `onFocusOut` is triggered right after `onTapOutside`.\n      // This workaround prevents duplicate `onFocusOut` call.\n      if (_this.onTapOutsideTimer) {\n        clearTimeout(_this.onTapOutsideTimer);\n        _this.onTapOutsideTimer = undefined;\n      }\n\n      _this._onFocusOut(event);\n    }, _this.onTapOutside = function (event) {\n      var onTapOutsideDelay = _this.props.onTapOutsideDelay;\n      clearTimeout(_this.onTapOutsideTimer);\n      _this.onTapOutsideTimer = setTimeout(function () {\n        // `onFocusOut` is triggered right after `onTapOutside`.\n        // This workaround prevents duplicate `onFocusOut` call.\n        if (_this.onTapOutsideTimer) {\n          _this._onFocusOut(event);\n        }\n\n        _this.onTapOutsideTimer = undefined;\n      }, onTapOutsideDelay);\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  _createClass(Expandable, [{\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      clearTimeout(this.scrollIntoViewTimer);\n      clearTimeout(this.removeFromDOMTimer);\n      clearTimeout(this.onTapOutsideTimer);\n    }\n  }, {\n    key: 'preload',\n    // Preload `<Expanded/>` content (if required).\n    value: function preload() {\n      var _this2 = this;\n\n      var _props = this.props,\n          preload = _props.preload,\n          onPreloadStateChange = _props.onPreloadStateChange;\n\n      if (preload) {\n        this.setState({\n          isPreloading: true\n        });\n\n        if (onPreloadStateChange) {\n          onPreloadStateChange(true);\n        }\n      }\n\n      return (preload ? preload() : Promise.resolve()).then(function () {\n        if (onPreloadStateChange) {\n          onPreloadStateChange(false);\n        }\n\n        _this2.setState({\n          isPreloading: false\n        });\n      }, function (error) {\n        console.error(error); // if (onPreloadError) {\n        // \tonPreloadError(error)\n        // }\n\n        if (onPreloadStateChange) {\n          onPreloadStateChange(false);\n        }\n\n        _this2.setState({\n          isPreloading: false\n        });\n      });\n    }\n  }, {\n    key: 'scrollIntoView',\n    value: function scrollIntoView() {\n      var _this3 = this;\n\n      var _props2 = this.props,\n          shouldScrollIntoView = _props2.scrollIntoView,\n          scrollIntoViewDelay = _props2.scrollIntoViewDelay,\n          expandAnimationDuration = _props2.expandAnimationDuration; // // For some reason in IE 11 \"scroll into view\" scrolls\n      // // to the top of the page, therefore turn it off for IE.\n      // if (!isInternetExplorer() && shouldScrollIntoView)\n\n      if (shouldScrollIntoView) {\n        this.scrollIntoViewTimer = setTimeout(function () {\n          var expanded = _this3.state.expanded; // If still expanded and there are any options\n          // then scroll into view.\n\n          if (expanded) {\n            // https://github.com/stipsan/scroll-into-view-if-needed/issues/359\n            // scrollIntoView(this.container, false, { duration: 300 })\n            (0, _scrollIntoViewIfNeeded2.default)(_this3.container, {\n              scrollMode: 'if-needed',\n              behavior: 'smooth',\n              block: 'nearest',\n              inline: 'nearest'\n            });\n          }\n        }, Math.max(scrollIntoViewDelay, expandAnimationDuration) * 1.1);\n      }\n    }\n  }, {\n    key: '_onFocusOut',\n    value: function _onFocusOut(event) {\n      var onFocusOut = this.props.onFocusOut;\n      this.focusOut = true;\n      onFocusOut(event);\n      this.focusOut = undefined;\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props3 = this.props,\n          alignment = _props3.alignment,\n          upward = _props3.upward,\n          onFocusOut = _props3.onFocusOut,\n          getTogglerNode = _props3.getTogglerNode,\n          closeLabel = _props3.closeLabel,\n          CloseButtonIcon = _props3.closeButtonIcon,\n          role = _props3.role,\n          style = _props3.style,\n          className = _props3.className,\n          children = _props3.children;\n      var _state = this.state,\n          shouldRender = _state.shouldRender,\n          expanded = _state.expanded;\n\n      if (!shouldRender) {\n        return null;\n      } // `tabIndex={ -1 }` makes the `<div/>` focusable.\n      // So that `<Expandable/>` doesn't collapse on click inside it (top, bottom).\n      // `aria-hidden={true/false}` is not set automatically here\n      // because when `<Expandable/>` is collapsed then it's not rendered.\n      // tabIndex={ -1 }\n\n\n      var element = _react2.default.createElement('div', {\n        ref: this.storeContainerNode,\n        onKeyDown: this.onKeyDown,\n        onBlur: this.onBlur,\n        role: role,\n        'aria-hidden': this.props['aria-hidden'],\n        'aria-label': this.props['aria-label'],\n        style: style,\n        className: (0, _classnames2.default)(className, 'rrui__shadow', 'rrui__expandable', 'rrui__expandable--overlay', {\n          'rrui__expandable--expanded': expanded,\n          'rrui__expandable--left-aligned': alignment === 'left',\n          'rrui__expandable--right-aligned': alignment === 'right',\n          'rrui__expandable--upward': upward,\n          'rrui__expandable--downward': !upward\n        })\n      }, _react2.default.Children.map(children, function (child) {\n        return _react2.default.cloneElement(child, {\n          className: (0, _classnames2.default)(child.props.className, 'rrui__expandable__content', {\n            'rrui__expandable__content--expanded': expanded\n          })\n        });\n      }), expanded && CloseButtonIcon && _react2.default.createElement(_Close2.default, {\n        onClick: this.collapse,\n        closeLabel: closeLabel,\n        className: (0, _classnames2.default)('rrui__close--bottom-right', 'rrui__expandable__close')\n      }, _react2.default.createElement(CloseButtonIcon, null)));\n\n      if (onFocusOut) {\n        element = _react2.default.createElement(_OnFocusOut2.default, {\n          ref: this.storeOnFocusOutRef,\n          getContainerNode: this.getContainerNode,\n          getTogglerNode: getTogglerNode,\n          onFocusOut: this.onFocusOut\n        }, element);\n      }\n\n      if (onFocusOut) {\n        element = _react2.default.createElement(_OnTapOutside2.default, {\n          ref: this.storeOnTapOutsideRef,\n          getContainerNode: this.getContainerNode,\n          getTogglerNode: getTogglerNode,\n          onTapOutside: this.onTapOutside\n        }, element);\n      }\n\n      return element;\n    }\n  }]);\n\n  return Expandable;\n}(PureComponent), _class.propTypes = {\n  // Can optionally preload `<Expandable/>` contents before expanding it.\n  // Must return a `Promise`.\n  preload: _propTypes2.default.func,\n  onPreloadStateChange: _propTypes2.default.func,\n  onPreloadError: _propTypes2.default.func,\n  onExpand: _propTypes2.default.func,\n  onCollapse: _propTypes2.default.func,\n  // Whether the `<Expandable/>` expands upwards or downwards.\n  alignment: _propTypes2.default.oneOf(['left', 'right']),\n  // If this flag is set to `true`,\n  // then the dropdown expands itself upward.\n  // (as opposed to the default downward)\n  upward: _propTypes2.default.bool,\n  // ARIA `role` (accessibility).\n  role: _propTypes2.default.string,\n  // CSS style object.\n  style: _propTypes2.default.object,\n  // CSS class.\n  className: _propTypes2.default.string,\n  // When the `<Expandable/>` is expanded\n  // its content may not fit on the screen.\n  // If `scrollIntoView` is `true` (which is the default)\n  // then the browser will automatically scroll\n  // so that the expanded content fits on the screen.\n  scrollIntoView: _propTypes2.default.bool.isRequired,\n  // If `scrollIntoView` is `true` (which is the default)\n  // then these two are gonna define the delay after which it scrolls into view.\n  expandAnimationDuration: _propTypes2.default.number.isRequired,\n  scrollIntoViewDelay: _propTypes2.default.number.isRequired,\n  getTogglerNode: _propTypes2.default.func,\n  onFocusOut: _propTypes2.default.func,\n  onTapOutsideDelay: _propTypes2.default.number.isRequired,\n  // `aria-label` for the \"Close\" button\n  // (which is an \"x\" visible in fullscreen mode).\n  closeLabel: _propTypes2.default.string,\n  // The \"x\" button icon that closes the `<Select/>`\n  // in fullscreen mode on mobile devices.\n  closeButtonIcon: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.oneOf([false])]).isRequired\n}, _class.defaultProps = {\n  scrollIntoView: true,\n  expandAnimationDuration: 150,\n  scrollIntoViewDelay: 0,\n  // `onFocusOut` is triggered right after `onTapOutside`.\n  // This workaround prevents duplicate `onFocusOut` call.\n  onTapOutsideDelay: 30,\n  // The \"x\" button icon that closes the `<Select/>`\n  // in fullscreen mode on mobile devices.\n  closeButtonIcon: _Close.CloseIcon\n}, _temp2);\nexports.default = Expandable;","map":null,"metadata":{},"sourceType":"script"}