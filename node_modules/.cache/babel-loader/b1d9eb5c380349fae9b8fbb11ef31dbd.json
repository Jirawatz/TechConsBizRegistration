{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Item = exports.default = undefined;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _class, _temp2, _class2, _temp4;\n\nexports.findItemIndexByValue = findItemIndexByValue;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _classnames = require('classnames');\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nvar _Divider = require('./Divider');\n\nvar _Divider2 = _interopRequireDefault(_Divider);\n\nvar _dom = require('./utility/dom');\n\nvar _focus = require('./utility/focus');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // `PureComponent` is only available in React >= 15.3.0.\n\n\nvar PureComponent = _react2.default.PureComponent || _react2.default.Component; // Workaround for `react-hot-loader`.\n// https://github.com/gaearon/react-hot-loader#checking-element-types\n\nvar DividerType = _react2.default.createElement(_Divider2.default, null).type;\n\nvar List = (_temp2 = _class = function (_PureComponent) {\n  _inherits(List, _PureComponent);\n\n  function List() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, List);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = List.__proto__ || Object.getPrototypeOf(List)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      items: _this.props.items // `ref`s of all items currently rendered.\n\n    }, _this.itemRefs = [], _this.input = '', _this.getFocusedItemIndex = function () {\n      return _this.state.focusedItemIndex;\n    }, _this.clearFocus = function () {\n      return _this.focusItem();\n    }, _this.unfocus = _this.clearFocus, _this.focus = function () {\n      var focusedItemIndex = _this.state.focusedItemIndex;\n\n      if (focusedItemIndex !== undefined) {\n        return _this.focusItem(focusedItemIndex);\n      } // // Focus the first focusable list item.\n      // this.focusItem(this.getFirstFocusableItemIndex())\n\n\n      _this.list.focus();\n    }, _this.focusItem = function (focusedItemIndex) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _this$props = _this.props,\n          onFocusItem = _this$props.onFocusItem,\n          shouldFocus = _this$props.shouldFocus;\n\n      if (onFocusItem) {\n        onFocusItem(focusedItemIndex, options);\n      }\n\n      _this.setState({\n        // Focus the item.\n        focusedItemIndex: focusedItemIndex,\n        // Store the focused item value.\n        // This is used for cases like autocomplete\n        // where the list of options changes but\n        // the focused option stays focused.\n        focusedItemValue: focusedItemIndex === undefined ? undefined : _this.getItemValue(focusedItemIndex)\n      }, function () {\n        // Actually focus the item.\n        if (focusedItemIndex !== undefined) {\n          if (shouldFocus && _this._isMounted) {\n            if (!(0, _focus.focus)(_this.itemRefs[focusedItemIndex])) {\n              console.error('<List.Item/> #' + (focusedItemIndex + 1) + '\\'s child component doesn\\'t have a \".focus()\" method.');\n            }\n          }\n        }\n      });\n    }, _this.onKeyDown = function (event) {\n      var _this$props2 = _this.props,\n          onKeyDown = _this$props2.onKeyDown,\n          children = _this$props2.children;\n      var focusedItemIndex = _this.state.focusedItemIndex;\n\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      if (event.defaultPrevented) {\n        return;\n      }\n\n      if ((0, _dom.submitFormOnCtrlEnter)(event, _this.input)) {\n        return;\n      }\n\n      if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n        return;\n      }\n\n      if (_react2.default.Children.count(children) > 0) {\n        switch (event.keyCode) {\n          // \"Up\" arrow.\n          // Select the previous item (if present).\n          case 38:\n            event.preventDefault();\n\n            var previousIndex = _this.getPreviousFocusableItemIndex();\n\n            if (previousIndex !== undefined) {\n              _this.focusItem(previousIndex, {\n                interaction: true\n              });\n            }\n\n            return;\n          // \"Down\" arrow.\n          // Select the next item (if present).\n\n          case 40:\n            event.preventDefault();\n\n            var nextIndex = _this.getNextFocusableItemIndex();\n\n            if (nextIndex !== undefined) {\n              _this.focusItem(nextIndex, {\n                interaction: true\n              });\n            }\n\n            return;\n        }\n      }\n    }, _this.onKeyPress = function (event) {\n      var resetInputTimeout = _this.props.resetInputTimeout;\n      var characters = event.char || String.fromCharCode(event.charCode);\n\n      if (characters) {\n        _this.input += characters;\n\n        _this.onInput();\n\n        clearTimeout(_this.resetInputTimer);\n        _this.resetInputTimer = setTimeout(_this.resetInput, resetInputTimeout);\n      }\n    }, _this.resetInput = function () {\n      return _this.input = '';\n    }, _this.isInputInProgress = function () {\n      return _this.input !== '';\n    }, _this.onInputSpacebar = function () {\n      if (_this.input) {\n        _this.input += ' ';\n      }\n    }, _this.onItemFocus = function (event) {\n      var expandable = _this.props.expandable;\n\n      if (expandable) {\n        return;\n      }\n\n      _this.onFocusIn();\n    }, _this.onBlur = function (event) {\n      var expandable = _this.props.expandable;\n\n      if (expandable) {\n        return;\n      }\n\n      clearTimeout(_this.blurTimer);\n      var result = (0, _focus.onBlur)(event, _this.onFocusOut, function () {\n        return _this.list;\n      });\n\n      if (typeof result === 'number') {\n        _this.blurTimer = result;\n      }\n    }, _this.onFocusIn = function () {\n      var onFocusIn = _this.props.onFocusIn;\n\n      if (onFocusIn) {\n        onFocusIn();\n      }\n\n      _this.setState({\n        isFocused: true\n      });\n    }, _this.onFocusOut = function () {\n      var value = _this.props.value;\n\n      if (value === undefined) {\n        _this.clearFocus();\n      }\n\n      _this.setState({\n        isFocused: false\n      });\n    }, _this.isFocusableItemIndex = function (index) {\n      return _this.itemRefs[index] !== undefined;\n    }, _this.isFocusableItem = function (item) {\n      return item.type !== DividerType;\n    }, _this.storeListNode = function (node) {\n      return _this.list = node;\n    }, _this.storeItemRef = function (ref, i) {\n      return _this.itemRefs[i] = ref;\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  } // For select options list keyboard navigation via typing.\n\n\n  _createClass(List, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var highlightFirstItem = this.props.highlightFirstItem;\n\n      if (highlightFirstItem) {\n        this.focusItem(0);\n      }\n\n      this._isMounted = true;\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _props = this.props,\n          value = _props.value,\n          items = _props.items,\n          children = _props.children,\n          highlightSelectedItem = _props.highlightSelectedItem,\n          highlightFirstItem = _props.highlightFirstItem; // If `items` property is supplied\n      // then it's used to detect \"on items changed\" event.\n\n      if (prevState.items && prevState.items !== items) {\n        this.setState({\n          items: items\n        }); // `findItemIndexByValue()` must return `undefined` for \"no such item\".\n\n        var selectedItemIndex = highlightSelectedItem ? findItemIndexByValue(value, children) : undefined;\n        this.focusItem(selectedItemIndex === undefined ? highlightFirstItem ? 0 : undefined : selectedItemIndex);\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      this._isMounted = false;\n      clearTimeout(this.blurTimer);\n      clearTimeout(this.resetInputTimer);\n    }\n  }, {\n    key: 'chooseFocusedItem',\n    value: function chooseFocusedItem() {\n      var focusedItemIndex = this.state.focusedItemIndex;\n\n      if (focusedItemIndex !== undefined) {\n        var itemRef = this.itemRefs[focusedItemIndex];\n\n        if (itemRef.click) {\n          itemRef.click();\n        }\n      }\n    } // Deprecated method name.\n    // Focuses the list.\n\n  }, {\n    key: 'getFirstFocusableItemIndex',\n    value: function getFirstFocusableItemIndex() {\n      var i = 0;\n\n      while (i < this.itemRefs.length) {\n        if (this.itemRefs[i]) {\n          return i;\n        }\n      }\n    }\n  }, {\n    key: 'getItemValue',\n    value: function getItemValue(index) {\n      var children = this.props.children;\n\n      var item = _react2.default.Children.toArray(children)[index];\n\n      return item.props.value;\n    } // Can be public API for programmatically focusing a certain `<List.Item/>`.\n\n  }, {\n    key: 'onInput',\n    value: function onInput() {\n      var children = this.props.children;\n      var index = findItemIndexByLabel(this.input, children);\n\n      if (index !== undefined) {\n        this.focusItem(index);\n      }\n    }\n  }, {\n    key: 'getPreviousFocusableItemIndex',\n    // Get the previous option (relative to the currently focused option)\n    value: function getPreviousFocusableItemIndex() {\n      var children = this.props.children;\n      var focusedItemIndex = this.state.focusedItemIndex;\n\n      if (focusedItemIndex === undefined) {\n        focusedItemIndex = _react2.default.Children.count(children);\n      }\n\n      while (focusedItemIndex > 0) {\n        focusedItemIndex--;\n\n        if (this.isFocusableItemIndex(focusedItemIndex)) {\n          return focusedItemIndex;\n        }\n      }\n    } // Get the next option (relative to the currently focused option)\n\n  }, {\n    key: 'getNextFocusableItemIndex',\n    value: function getNextFocusableItemIndex() {\n      var children = this.props.children;\n      var focusedItemIndex = this.state.focusedItemIndex;\n\n      if (focusedItemIndex === undefined) {\n        focusedItemIndex = -1;\n      }\n\n      while (focusedItemIndex < _react2.default.Children.count(children) - 1) {\n        focusedItemIndex++;\n\n        if (this.isFocusableItemIndex(focusedItemIndex)) {\n          return focusedItemIndex;\n        }\n      }\n    } // `this.list` is also being accessed from `<ScrollableList/>`.\n\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var _props2 = this.props,\n          id = _props2.id,\n          expandable = _props2.expandable,\n          disabled = _props2.disabled,\n          tabbable = _props2.tabbable,\n          value = _props2.value,\n          hasOnChange = _props2.hasOnChange,\n          onChange = _props2.onChange,\n          onSelectItem = _props2.onSelectItem,\n          highlightSelectedItem = _props2.highlightSelectedItem,\n          createButtons = _props2.createButtons,\n          className = _props2.className,\n          style = _props2.style,\n          children = _props2.children;\n      var role = this.props.role;\n      var _state = this.state,\n          focusedItemIndex = _state.focusedItemIndex,\n          isFocused = _state.isFocused; // ARIA (accessibility) roles info:\n      // https://www.w3.org/TR/wai-aria-practices/examples/listbox/listbox-collapsible.html\n\n      if (!role && (onChange || onSelectItem)) {\n        role = 'listbox';\n      } // if (this.props['aria-hidden']) {\n      // \trole = undefined\n      // }\n      // `tabIndex={ -1 }` makes the `<ul/>` focusable.\n      // So that `<Expandable/>` doesn't collapse on click inside it (top, bottom).\n\n\n      return _react2.default.createElement('ul', {\n        ref: this.storeListNode,\n        id: id,\n        role: role,\n        'aria-label': this.props['aria-label'],\n        'aria-hidden': this.props['aria-hidden'],\n        'aria-required': this.props['aria-required'],\n        'aria-invalid': this.props['aria-invalid'],\n        onFocus: this.onFocusIn,\n        onKeyDown: this.onKeyDown,\n        onKeyPress: this.onKeyPress,\n        tabIndex: -1,\n        style: style,\n        className: (0, _classnames2.default)(className, 'rrui__outline', 'rrui__list', {\n          'rrui__list--focus': isFocused\n        })\n      }, _react2.default.Children.map(children, function (item, i) {\n        if (item.type !== ItemType) {\n          throw new Error('Only <List.Item/>s can be placed inside a <List/> (and remove any whitespace).');\n        }\n\n        return _react2.default.cloneElement(item, {\n          key: i,\n          index: i,\n          itemRef: _this2.isFocusableItem(item) ? _this2.storeItemRef : undefined,\n          role: role === 'listbox' ? 'option' : item.props.role,\n          focus: _this2.focusItem,\n          focused: (expandable || isFocused) && focusedItemIndex === i,\n          disabled: disabled || item.props.disabled,\n          tabIndex: tabbable && (focusedItemIndex === undefined ? i === 0 : i === focusedItemIndex) ? 0 : -1,\n          createButton: createButtons,\n          isInputInProgress: _this2.isInputInProgress,\n          onInputSpacebar: _this2.onInputSpacebar,\n          onItemFocus: _this2.onItemFocus,\n          onItemBlur: _this2.onBlur,\n          onSelectItem: onChange || onSelectItem,\n          hasOnSelectItem: hasOnChange,\n          selectedItemValue: value,\n          highlightSelectedItem: (onChange || onSelectItem) && highlightSelectedItem\n        });\n      }));\n    }\n  }]);\n\n  return List;\n}(PureComponent), _class.propTypes = {\n  // (optional) HTML `id` attribute.\n  // Can be used for WAI-ARIA stuff.\n  // Example: `<input role=\"combobox\"/>` with `aria-owns={listId}`.\n  id: _propTypes2.default.string,\n  value: _propTypes2.default.any,\n  onChange: _propTypes2.default.func,\n  // If a `<List/>` has `onChange` then it wraps `<List.Item/>`s with `<button/>`s.\n  // The `onChange` added by `<ExpandableList/>` overrides the original `onChange`.\n  // If there was no `onChange` — there will be one.\n  // So to retain that info `hasOnChange` property is used as a workaround.\n  // `undefined` means \"ignore this property\".\n  hasOnChange: _propTypes2.default.bool,\n  // If `items` property is supplied then it's used to\n  // detect \"on items changed\" event in `getDerivedStateFromProps`.\n  // It seems to be the only usage of the `items` property.\n  items: _propTypes2.default.arrayOf(_propTypes2.default.object),\n  // Legacy method, use `onChange` instead.\n  onSelectItem: _propTypes2.default.func,\n  highlightSelectedItem: _propTypes2.default.bool.isRequired,\n  onFocusIn: _propTypes2.default.func,\n  onFocusItem: _propTypes2.default.func,\n  onKeyDown: _propTypes2.default.func,\n  // ARIA `role` attribute.\n  role: _propTypes2.default.string,\n  // If a `<List/>` is `expandable`\n  // then it won't be `.rrui__list:not(.rrui__list--focus)`.\n  // `.rrui__list:not(.rrui__list--focus)` is only for standalone lists.\n  expandable: _propTypes2.default.bool,\n  tabbable: _propTypes2.default.bool.isRequired,\n  shouldFocus: _propTypes2.default.bool.isRequired,\n  highlightFirstItem: _propTypes2.default.bool.isRequired,\n  createButtons: _propTypes2.default.bool.isRequired,\n  // For select options list keyboard navigation via typing.\n  resetInputTimeout: _propTypes2.default.number.isRequired\n}, _class.defaultProps = {\n  tabbable: true,\n  shouldFocus: true,\n  highlightFirstItem: false,\n  createButtons: true,\n  highlightSelectedItem: true,\n  resetInputTimeout: 1000\n}, _temp2);\nexports.default = List;\nvar Item = exports.Item = (_temp4 = _class2 = function (_React$Component) {\n  _inherits(Item, _React$Component);\n\n  function Item() {\n    var _ref2;\n\n    var _temp3, _this3, _ret2;\n\n    _classCallCheck(this, Item);\n\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return _ret2 = (_temp3 = (_this3 = _possibleConstructorReturn(this, (_ref2 = Item.__proto__ || Object.getPrototypeOf(Item)).call.apply(_ref2, [this].concat(args))), _this3), _this3.onButtonKeyDown = function (event) {\n      var _this3$props = _this3.props,\n          isInputInProgress = _this3$props.isInputInProgress,\n          onInputSpacebar = _this3$props.onInputSpacebar;\n\n      if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n        return;\n      }\n\n      switch (event.keyCode) {\n        // \"Spacebar\".\n        case 32:\n          // If the user is currently typing.\n          if (isInputInProgress()) {\n            // Don't press the option button.\n            event.preventDefault(); // Append space character.\n\n            onInputSpacebar();\n          }\n\n      }\n    }, _this3.onMouseDown = function (event) {\n      var _this3$props2 = _this3.props,\n          value = _this3$props2.value,\n          index = _this3$props2.index,\n          focus = _this3$props2.focus,\n          children = _this3$props2.children; // If `<List.Item/>` child element gets wrapped in a `<button/>`\n      // then call `onMouseDown` defined on the `<List.Item/>`.\n      // If `<List.Item/>` child element doesn't get wrapped in a `<button/>`\n      // then manually call `onMouseDown` defined on the `<List.Item/>` child element\n      // because `onMouseDown` gets overridden for `<List.Item/>` child element.\n\n      var onMouseDown = _this3.shouldCreateButton() ? _this3.props.onMouseDown : children.props.onMouseDown; // Without this Safari (both mobile and desktop)\n      // won't select any item in an expanded list\n      // because it will collapse the list immediately\n      // on `mouseDown` due to `blur` event being fired.\n\n      event.preventDefault();\n\n      if (_this3.isSelectable()) {\n        focus(index);\n      }\n\n      if (onMouseDown) {\n        onMouseDown(event);\n      }\n    }, _this3.onFocus = function (event) {\n      var _this3$props3 = _this3.props,\n          focus = _this3$props3.focus,\n          index = _this3$props3.index,\n          onItemFocus = _this3$props3.onItemFocus,\n          children = _this3$props3.children; // If `<List.Item/>` child element gets wrapped in a `<button/>`\n      // then call `onFocus` defined on the `<List.Item/>`.\n      // If `<List.Item/>` child element doesn't get wrapped in a `<button/>`\n      // then manually call `onFocus` defined on the `<List.Item/>` child element\n      // because `onFocus` gets overridden for `<List.Item/>` child element.\n\n      var onFocus = _this3.shouldCreateButton() ? _this3.props.onFocus : children.props.onFocus;\n\n      if (_this3.isSelectable()) {\n        focus(index);\n      }\n\n      if (onFocus) {\n        onFocus(event);\n      }\n\n      if (onItemFocus) {\n        onItemFocus(event);\n      }\n    }, _this3.onBlur = function (event) {\n      var _this3$props4 = _this3.props,\n          onItemBlur = _this3$props4.onItemBlur,\n          children = _this3$props4.children; // If `<List.Item/>` child element gets wrapped in a `<button/>`\n      // then call `onBlur` defined on the `<List.Item/>`.\n      // If `<List.Item/>` child element doesn't get wrapped in a `<button/>`\n      // then manually call `onFocus` defined on the `<List.Item/>` child element\n      // because `onBlur` gets overridden for `<List.Item/>` child element.\n\n      var onBlur = _this3.shouldCreateButton() ? _this3.props.onBlur : children.props.onBlur;\n\n      if (onBlur) {\n        onBlur(event);\n      }\n\n      if (onItemBlur) {\n        onItemBlur(event);\n      }\n    }, _this3.onClick = function (event) {\n      var _this3$props5 = _this3.props,\n          onClick = _this3$props5.onClick,\n          onSelect = _this3$props5.onSelect,\n          onSelectItem = _this3$props5.onSelectItem,\n          index = _this3$props5.index,\n          value = _this3$props5.value,\n          children = _this3$props5.children; // If `<List.Item/>` child element gets wrapped in a `<button/>`\n      // then call `onClick` defined on the `<List.Item/>`.\n      // If `<List.Item/>` child element doesn't get wrapped in a `<button/>`\n      // then manually call `onClick` defined on the `<List.Item/>` child element\n      // because `onClick` gets overridden for `<List.Item/>` child element,\n      // and also call `onClick` defined on the `<List.Item/>` (if any).\n\n      if (onClick) {\n        onClick(event);\n      }\n\n      if (!_this3.shouldCreateButton()) {\n        // Since `onClick` gets overridden\n        // for `<List.Item/>` child element\n        // call its original `onClick` manually here.\n        if (children.props.onClick) {\n          children.props.onClick(event);\n        }\n      }\n\n      if (_this3.isSelectable()) {\n        if (onSelect) {\n          onSelect(value, index);\n        }\n\n        if (onSelectItem) {\n          onSelectItem(value, index);\n        }\n      }\n    }, _this3.focus = function () {\n      var children = _this3.props.children;\n      (0, _focus.focus)(_react2.default.Children.toArray(children)[0]);\n    }, _this3.storeRef = function (ref) {\n      var _this3$props6 = _this3.props,\n          itemRef = _this3$props6.itemRef,\n          index = _this3$props6.index;\n\n      if (itemRef) {\n        itemRef(ref, index);\n      }\n    }, _temp3), _possibleConstructorReturn(_this3, _ret2);\n  }\n\n  _createClass(Item, [{\n    key: 'isSelectable',\n    value: function isSelectable() {\n      return isSelectableItem(this);\n    } // Perhaps this is called by `focus()` utility function.\n    // Something like: `focus(this.itemRefs[i])`.\n\n  }, {\n    key: 'shouldCreateButton',\n    value: function shouldCreateButton() {\n      var _props3 = this.props,\n          onClick = _props3.onClick,\n          onSelect = _props3.onSelect,\n          onSelectItem = _props3.onSelectItem,\n          hasOnSelectItem = _props3.hasOnSelectItem,\n          createButton = _props3.createButton,\n          shouldCreateButton = _props3.shouldCreateButton;\n      return this.isSelectable() && (onClick || onSelect || onSelectItem && (hasOnSelectItem === undefined ? true : hasOnSelectItem) && (createButton || shouldCreateButton));\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props4 = this.props,\n          id = _props4.id,\n          value = _props4.value,\n          icon = _props4.icon,\n          role = _props4.role,\n          focused = _props4.focused,\n          disabled = _props4.disabled,\n          className = _props4.className,\n          tabIndex = _props4.tabIndex,\n          highlightSelectedItem = _props4.highlightSelectedItem,\n          selectedItemValue = _props4.selectedItemValue,\n          children = _props4.children; // Throws an error for some weird reason.\n      // React.Children.only(children)\n\n      if (_react2.default.Children.count(children) !== 1) {\n        throw new Error('Each <List.Item/> must have a single child (and remove any whitespace).');\n      }\n\n      var isSelected = this.shouldCreateButton() && value === selectedItemValue;\n      var properties = {\n        ref: this.storeRef,\n        onMouseDown: this.onMouseDown,\n        onClick: this.onClick,\n        onFocus: this.onFocus,\n        onBlur: this.onBlur,\n        className: (0, _classnames2.default)(className, 'rrui__list__item', {\n          /* `--focused` modifier is deprecated, use `--focus` instead. */\n          'rrui__list__item--focused': focused,\n          'rrui__list__item--focus': focused,\n          'rrui__list__item--selected': isSelected && highlightSelectedItem,\n          'rrui__list__item--disabled': disabled,\n          'rrui__list__item--divider': children.type === DividerType\n        })\n      };\n\n      if (id !== undefined) {\n        properties.id = id;\n      }\n\n      if (tabIndex !== undefined) {\n        properties.tabIndex = tabIndex;\n      }\n\n      var ItemComponent = void 0;\n      var itemChildren = void 0;\n      var label = void 0;\n\n      if (this.shouldCreateButton()) {\n        ItemComponent = 'button';\n        label = getItemLabel(this);\n        properties.type = 'button';\n        properties.role = role;\n        properties['aria-selected'] = isSelected;\n        properties['aria-label'] = this.props.label || (typeof children !== 'string' && children && children.props ? children.props['aria-label'] : undefined);\n        properties.disabled = disabled;\n        properties.onKeyDown = this.onButtonKeyDown;\n        properties.className = (0, _classnames2.default)(properties.className, 'rrui__button-reset', 'rrui__outline', 'rrui__list__item--button'); // Replace `itemChildren` array with `<React.Fragment/>`\n        // in some future when React >= 16.2.0 is common.\n        //\n        // <React.Fragment>\n        // \t{/* Icon. */}\n        // \t{ icon &&\n        // \t\t<div className=\"rrui__list__item-icon\">\n        // \t\t\t{ React.createElement(icon, { value, label }) }\n        // \t\t</div>\n        // \t}\n        //\n        // \t{/* Label (or content). */}\n        // \t{ children }\n        // </React.Fragment>\n        // Label (or content).\n\n        itemChildren = _react2.default.Children.toArray(children); // Icon.\n\n        if (icon) {\n          itemChildren.unshift(_react2.default.createElement('span', {\n            key: 'icon',\n            'aria-hidden': true,\n            className: 'rrui__list__item-icon'\n          }, _react2.default.createElement(icon, {\n            value: value,\n            label: label\n          })));\n        }\n      } else {\n        // Don't overwrite `className` already defined on the `children`.\n        properties.className = (0, _classnames2.default)(properties.className, children.props && children.props.className);\n      }\n\n      return _react2.default.createElement('li', {\n        role: this.shouldCreateButton() || children.type === DividerType ? 'presentation' : role,\n        'aria-selected': this.shouldCreateButton() ? undefined : role && role !== 'presentation' ? isSelected : undefined,\n        'aria-label': this.shouldCreateButton() ? undefined : label,\n        className: 'rrui__list__list-item'\n      }, ItemComponent && _react2.default.createElement(ItemComponent, properties, itemChildren), !ItemComponent && _react2.default.cloneElement(children, properties));\n    }\n  }]);\n\n  return Item;\n}(_react2.default.Component), _class2.propTypes = {\n  // (optional) HTML `id` attribute.\n  // Can be used for WAI-ARIA stuff.\n  // Example: `<input role=\"combobox\"/>` with `aria-activedescendant={focusedListItemId}`.\n  id: _propTypes2.default.string,\n  value: _propTypes2.default.any,\n  index: _propTypes2.default.number,\n  focused: _propTypes2.default.bool,\n  onClick: _propTypes2.default.func,\n  // `onSelect` is deprecated, use `onClick` instead.\n  onSelect: _propTypes2.default.func,\n  onSelectItem: _propTypes2.default.func,\n  // If a `<List/>` has `onChange` then it wraps `<List.Item/>`s with `<button/>`s.\n  // The `onChange` added by `<ExpandableList/>` overrides the original `onChange`.\n  // If there was no `onChange` — there will be one.\n  // So to retain that info `hasOnChange` property is used as a workaround.\n  // `undefined` means \"ignore this property\".\n  hasOnSelectItem: _propTypes2.default.bool,\n  selectedItemValue: _propTypes2.default.any,\n  highlightSelectedItem: _propTypes2.default.bool,\n  createButton: _propTypes2.default.bool,\n  // Deprecated. Use `createButton` instead.\n  shouldCreateButton: _propTypes2.default.bool,\n  // The button won't be pressed on \"Space\" key\n  // if the user is currently typing.\n  isInputInProgress: _propTypes2.default.func,\n  onInputSpacebar: _propTypes2.default.func\n}, _temp4);\nList.Item = Item; // Workaround for `react-hot-loader`.\n// https://github.com/gaearon/react-hot-loader#checking-element-types\n\nvar ItemType = _react2.default.createElement(Item, null).type;\n\nfunction haveItemsChanged(props, prevProps) {\n  var items = _react2.default.Children.toArray(props.children);\n\n  var prevItems = _react2.default.Children.toArray(prevProps.children);\n\n  if (items.length !== prevItems.length) {\n    return true;\n  }\n\n  var i = 0;\n\n  while (i < items.length) {\n    if (items[i].props.value !== prevItems[i].props.value) {\n      return true;\n    }\n\n    i++;\n  }\n\n  return false;\n}\n\nfunction findItemIndexByValue(value, children) {\n  var items = _react2.default.Children.toArray(children);\n\n  var i = 0;\n\n  for (var _iterator = items, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref3;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref3 = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref3 = _i.value;\n    }\n\n    var item = _ref3;\n\n    if (isSelectableItem(item) && item.props.value === value) {\n      return i;\n    }\n\n    i++;\n  }\n}\n\nfunction findItemIndexByLabel(value, children) {\n  var items = _react2.default.Children.toArray(children);\n\n  var i = 0;\n\n  for (var _iterator2 = items, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n    var _ref4;\n\n    if (_isArray2) {\n      if (_i2 >= _iterator2.length) break;\n      _ref4 = _iterator2[_i2++];\n    } else {\n      _i2 = _iterator2.next();\n      if (_i2.done) break;\n      _ref4 = _i2.value;\n    }\n\n    var item = _ref4;\n\n    if (isSelectableItem(item)) {\n      var itemLabel = getItemLabel(item);\n\n      if (itemLabel && itemLabel.toLowerCase().indexOf(value.toLowerCase()) === 0) {\n        return i;\n      }\n    }\n\n    i++;\n  }\n}\n\nfunction getItemLabel(item) {\n  return item.props.label || (typeof item.props.children === 'string' ? item.props.children : undefined);\n}\n\nfunction isSelectableItem(item) {\n  return item.props.children && item.props.children.type !== DividerType;\n}","map":null,"metadata":{},"sourceType":"script"}